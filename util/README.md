# Explanation of Utility Functions

## The Matrix Structure and Related Operations

> global_notation.[h/cpp]

In `global_notation.[h/cpp]`, we implement the matrix structure. The gate matrix of common quantum gates are recorded. Related operations, including matrix initialization, tensor-product, addition and multiplication are implemented. 

## The Quantum Gate and Circuit Structures

> matrix_wrap.[h/cpp]

In `matrix_wrap.[h/cpp]`, we implement the wrapping structures of quantum gates. Actually there are two types of such structures, `Gate` and `MatrixImp`. `Gate` is used for the quantum gates of *qHiPSTER* and *SingleQE*, while `MatrixImp` is used for *MultiQE*, *QuanPath* and *QuanTrans*. The quantum circuits are represented by `vector<vector<Gate> >` and `vector<vector<MatrixImp> >`, respectively. What's more, the generation of such quantum circuit structures from a given input file generated by `output_circuit.py` in `../preprocess` directory is implemented in this file. 

## Generate 2-qubit Controlled Gate Matrices

> gen_gate.[h/cpp]

In `gen_gate.cpp`, we implement the generation of the operation-matrix for arbitrary controlled gates. 

In *QuanPath* and *QuanTrans*, gates on low-order qubits are simulated using the indexing algorithm locally on each node (which will be discussed below), while operations on the high-order `h` qubits require constructing the operation-matrix. Therefore, we can relabel the high-order `h` qubits from lower qubits to higher qubits as `0`, `1`, `2`, ..., `h-1`.

**Case 1: a higher qubit controls a lower qubit**


**Case 2: a lower qubit controls a higher qubit**


## Local Indexing

> indexing.[h/cpp]

Indexing is a useful algorithm for simulation of quantum circuits, especially in distributed situations. Its implementation is in `indexing.[h/cpp]`. 